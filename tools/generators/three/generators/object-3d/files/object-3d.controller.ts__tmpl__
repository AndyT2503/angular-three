// GENERATED

import {
  Directive,
  EventEmitter,
  Input,
  OnChanges,
  OnInit,
  Output,
  SimpleChanges,
} from '@angular/core';
import { ReplaySubject } from 'rxjs';
import * as THREE from 'three';
import type {
  NgtColor,
  NgtEuler,
  NgtEvent,
  NgtQuaternion,
  NgtVector3,
  UnknownRecord,
} from '../models';

@Directive({
  selector: `
    ngt-primitive,
    ngt-mesh,
    ngt-instanced-mesh,
    ngt-skinned-mesh,
    ngt-bone,
    ngt-line2,
    ngt-line-segments2,
    ngt-wireframe,
    ngt-group,
    ngt-lod,
    ngt-scene,
    ngt-points,
    ngt-cube-camera,
    ngt-contact-shadows,
    ngt-image,
    ngt-text,
    ngt-html<% if (selectors.length) { %>,<% } %><% for (const selector of selectors) { %>
    ngt-<%= selector.selector %><% if (!selector.isLast) { %>,<% } %><% } %>
  `,
  exportAs: 'ngtObject3dController',
})
export class NgtObject3dController implements OnChanges, OnInit {
  @Input() name?: string;
  @Input() position?: NgtVector3;
  @Input() rotation?: NgtEuler;
  @Input() quaternion?: NgtQuaternion;
  @Input() scale?: NgtVector3;
  @Input() color?: NgtColor;
  @Input() userData?: UnknownRecord;
  @Input() dispose?: () => void;
  @Input() castShadow = false;
  @Input() receiveShadow = false;
  @Input() visible = true;
  @Input() matrixAutoUpdate = true;

  @Input() appendMode: 'immediate' | 'root' = 'immediate';
  @Input() appendTo?: THREE.Object3D;

  @Input() controller?: NgtObject3dController;

  // events
  @Output() click = new EventEmitter<NgtEvent<MouseEvent>>();
  @Output() contextmenu = new EventEmitter<NgtEvent<MouseEvent>>();
  @Output() dblclick = new EventEmitter<NgtEvent<MouseEvent>>();
  @Output() pointerup = new EventEmitter<NgtEvent<PointerEvent>>();
  @Output() pointerdown = new EventEmitter<NgtEvent<PointerEvent>>();
  @Output() pointerover = new EventEmitter<NgtEvent<PointerEvent>>();
  @Output() pointerout = new EventEmitter<NgtEvent<PointerEvent>>();
  @Output() pointerenter = new EventEmitter<NgtEvent<PointerEvent>>();
  @Output() pointerleave = new EventEmitter<NgtEvent<PointerEvent>>();
  @Output() pointermove = new EventEmitter<NgtEvent<PointerEvent>>();
  @Output() pointermissed = new EventEmitter<NgtEvent<PointerEvent>>();
  @Output() pointercancel = new EventEmitter<NgtEvent<PointerEvent>>();
  @Output() wheel = new EventEmitter<NgtEvent<WheelEvent>>();

  readonly change$ = new ReplaySubject<SimpleChanges>(1);

  ngOnChanges(changes: SimpleChanges) {
    if (this.controller) {
      this.controller.ngOnChanges(changes);
    } else {
      this.change$.next(changes);
    }
  }

  ngOnInit() {
    if (this.controller) {
      this.name = this.controller.name;
      this.position = this.controller.position;
      this.rotation = this.controller.rotation;
      this.quaternion = this.controller.quaternion;
      this.scale = this.controller.scale;
      this.color = this.controller.color;
      this.userData = this.controller.userData;
      this.dispose = this.controller.dispose;
      this.castShadow = this.controller.castShadow;
      this.receiveShadow = this.controller.receiveShadow;
      this.visible = this.controller.visible;
      this.matrixAutoUpdate = this.controller.matrixAutoUpdate;
      this.appendMode = this.controller.appendMode;
      this.appendTo = this.controller.appendTo;

      this.click = this.controller.click;
      this.contextmenu = this.controller.contextmenu;
      this.dblclick = this.controller.dblclick;
      this.pointerup = this.controller.pointerup;
      this.pointerdown = this.controller.pointerdown;
      this.pointerover = this.controller.pointerover;
      this.pointerout = this.controller.pointerout;
      this.pointerenter = this.controller.pointerenter;
      this.pointerleave = this.controller.pointerleave;
      this.pointermove = this.controller.pointermove;
      this.pointermissed = this.controller.pointermissed;
      this.pointercancel = this.controller.pointercancel;
      this.wheel = this.controller.wheel;
    }
  }

  get object3dProps() {
    return {
      name: this.name,
      position: this.position,
      rotation: this.rotation,
      quaternion: this.quaternion,
      scale: this.scale,
      color: this.color,
      userData: this.userData,
      dispose: this.dispose,
      castShadow: this.castShadow,
      receiveShadow: this.receiveShadow,
      visible: this.visible,
      matrixAutoUpdate: this.matrixAutoUpdate,
    }
  }
}
