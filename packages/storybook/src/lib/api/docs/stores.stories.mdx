import { Meta } from '@storybook/addon-docs';

<Meta title={'API/Stores'} parameters={{ viewMode: 'docs' }} />

# Component Stores

As we have already seen, NGT makes use of `@ngrx/component-store` to provide a way to manage the state of everything happening in the Canvas. These stores are provided by the `ngt-canvas` component and are available to all children of `ngt-canvas` via [Hierarchical Dependency Injection](https://angular.io/guide/hierarchical-dependency-injection)

Even though we want to avoid Imperative State Management, it is almost unavoidable such problem when working with an imperative library like THREE.js. Hence, all the component stores in NGT expose `getImperativeState()` method that can retrieve the state at the time of invoking. This is especially helpful when registering animation callbacks. Since animation callbacks are invoked on every frame, `getImperativeState()` will almost always guarantee to return the latest and freshest state.

All stores also expose two objects: `updaters` and `selectors`.

- `updaters` is a collection of functions that can be used to update the state of the store.
- `selectors` is a collection of functions that can be used to retrieve the state of the store via `Observable`.

## `NgtStore`

This store is the main store for the Canvas. It is responsible for keeping the Renderer, Scene, Camera, and other states/configurations for the 3 main building blocks. It also contains information about the Viewport like Size and Device Pixel Ratio (DPR).

## `NgtCanvasInputsStore`

This store is responsible for keeping the inputs for the Canvas. It uses to provide the default configurations for `NgtStore`, and to update the configurations when the consumers pass in values via `ngt-canvas` Inputs.

## `NgtAnimationFrameStore`

This store keeps track of all the animation callbacks that are registered. Animations are registered via two ways:

- `(animateReady)` Output
- `NgtAnimationFrameStore#register`

The difference between the two is that the former subscribes a single object to the Animation Frame.

```html
<ngt-mesh (animateReady)="onThisMeshAnimate()"></ngt-mesh>
<ngt-mesh (animateReady)="onThatMeshAnimate()"></ngt-mesh>
```

Some time, it works well. But when you need to orchestrate both meshes through each frame, you cannot use `(animateReady)`. Instead, you can inject `NgtAnimationFrameStore` and call the `register()` method.

```ts
@Component({
  selector: 'two-meshes',
  template: `
    <ngt-mesh #meshOne></ngt-mesh>
    <ngt-mesh #meshTwo></ngt-mesh>
  `,
})
export class TwoMeshesComponent {
  @ViewChild('meshOne') meshOne: NgtMesh;
  @ViewChild('meshTwo') meshTwo: NgtMesh;

  private animationSubscription?: Subscription;

  constructor(private animationFrameStore: NgtAnimationFrameStore) {}

  ngOnInit() {
    this.animationSubscription = this.animationFrameStore.register({
      obj: null,
      callback: () => {
        this.meshOne.mesh.rotation.y += 0.01;
        this.meshTwo.mesh.rotation.y += 0.01;
      },
    });
  }

  ngOnDestroy() {
    this.animationFrameStore?.unsubscribe();
  }
}
```

`NgtAnimationFrameStore#register` returns a `Subscription` which we can use to `unsubscribe` and unregister the animation callback.

## `NgtInstancesStore`

This store keeps track of the object instances that were created. This store is **internal** but it is exposed to the consumers. `NgtInstancesStore` is mainly used to store the `NgtMaterial` and `NgtGeometry` instances for reuse purposes.

Imagine we have three meshes with the exact same Geometry and Material. We can construct them like below:

```html
<ngt-mesh [position]="[1, 1, 1]">
  <ngt-box-geometry></ngt-box-geometry>
  <ngt-mesh-standard-material
    [parameters]='{color: "red"}'
  ></ngt-mesh-standard-material>
</ngt-mesh>

<ngt-mesh [position]="[2, 2, 2]">
  <ngt-box-geometry></ngt-box-geometry>
  <ngt-mesh-standard-material
    [parameters]='{color: "red"}'
  ></ngt-mesh-standard-material>
</ngt-mesh>

<ngt-mesh [position]="[3, 3, 3]">
  <ngt-box-geometry></ngt-box-geometry>
  <ngt-mesh-standard-material
    [parameters]='{color: "red"}'
  ></ngt-mesh-standard-material>
</ngt-mesh>
```

This is, not the end of the world, but it is not efficient. We can construct the Geometry and Material once then reuse on the meshes.

```html
<ngt-box-geometry ngtId="boxGeometry"></ngt-box-geometry>
<ngt-mesh-standard-material
  ngtId="standardMaterial"
  [parameters]='{color: "red"}'
></ngt-mesh-standard-material>

<ngt-mesh
  [position]="[1, 1, 1]"
  geometry="boxGeometry"
  material="standardMaterial"
></ngt-mesh>
<ngt-mesh
  [position]="[2, 2, 2]"
  geometry="boxGeometry"
  material="standardMaterial"
></ngt-mesh>
<ngt-mesh
  [position]="[3, 3, 3]"
  geometry="boxGeometry"
  material="standardMaterial"
></ngt-mesh>
```

## `NgtEventsStore`

This store handles the Events inside the Canvas with `Raycaster` and `Intersection` objects. This store is internal, but it is exposed to the consumers. We should never have a need to use this store directly.

## `NgtPerformanceStore`

TBD. Examples needed before explaining.
